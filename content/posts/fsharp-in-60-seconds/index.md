---
layout: post
title: "Синтакс F# за 60 секунд"
description: "Очень быстрый обзор как читать F# код"
date: 2012-04-02
nav: why-use-fsharp
seriesId: "Зачем использовать F#?"
seriesCode: why-use-fsharp
seriesOrder: 2
---

Это очень быстрый обзор, как читать F# код для новичков, незнакомых с синтаксисом.

Очевидно, что он не очень детальный, но достаточный для чтения и чтобы уловить суть предстоящих примеров в этой серии. Не переживайте, если вы не полностью понимаете все из этого, т.к. я дам более детальное объяснение, когда мы перейдем к примерам кода.

Двумя главными различиями между синтаксисом F# и стандартным С-подобным синтаксисом являются:

* Фигурные скобки не используются для разделения блоков кода. Вместо этого используются отступы (аналогично Python-у).
* Для разделения параметров используются пробелы, а не запятые.

Некоторые люди находят синтаксис F# оталкивающим. Если вы один из них, обратите внимание на эту цитату:

> "Оптимизация вашей нотации, чтобы она не смущала людей в первые 10 минут, после того как они ее увидят, но которая затруднит читаемость в дальнейшем - это очень большая ошибка."
> (David MacIver, из [статьи о синтаксисе Scala](http://rickyclarkson.blogspot.co.uk/2008/01/in-defence-of-0l-in-scala.html)).

Лично я считаю что синтаксис F# очень понятен и прост, когда Вы к нему привыкнете. Во многих случаях он проще, чем синтаксис C#, с меньшим количеством ключевых слов и особых случаев.

Код примера ниже - это простой скрипт на языке F#, который демонстрирует большинство концепций, которые вам нужны регулярно.

Я бы посоветовал вам протестировать этот код в интерактивном режиме и немного поиграть с ним! Или:

* Наберите этот код в файле для скриптов F# (с расширением .fsx)
и отправьте его в F# Interactive. Смотрите ["установка и использование F#"](/installing-and-using/) для деталей.
* В качестве альтернативы, попробуйте запустить этот код в интерактивном окне. Не забывайте всегда использовать `;;` в конце чтобы сказать
интерпретатору что вы завершили ввод и его можно исполнять.


```fsharp
// однострочные комментарии используют двойную косую черту
(* многострочные коментарии используют пару (* . . . *)

-конец многострочного коментария- *)

// ======== "Переменные" (но не совсем) ==========
// Ключевое слово "let" определяет (неизменяемое) значение
let myInt = 5
let myFloat = 3.14
let myString = "hello"	//обратите внимание, что никаких типов не требуется

// ======== Списки ============
let twoToFive = [2;3;4;5]        // Квадратные скобки создают список с
                                 // точками с запятой в качестве разделителя.
let oneToFive = 1 :: twoToFive   // :: создает список с новым первым элементом
// Результат [1;2;3;4;5]
let zeroToFive = [0;1] @ twoToFive   // @ соединяет два списка 

// ВАЖНО: запятые никогда не используются в качестве разделителей, только точки с запятой!

// ======== Функции ========
// Ключевое слово "let" так же определяет именованную функцию.
let square x = x * x          // Обратите внимание, что круглые скобки не используются.
square 3                      // Сейчас запустим функцию. И снова нет скобок.

let add x y = x + y           // не используйте add (x,y)! Это означает
                              // совершенно другое.
add 2 3                       // И запустим функцию.

// чтобы определить многострочную функцию, просто используйте отступы. Точки с запятой не нужны.
let evens list =
   let isEven x = x%2 = 0     // Определяем "isEven" в качестве внутренней ("вложенной") функции
   List.filter isEven list    // List.filter - это библиотечная функция
                              // с двумя параметрами: булева функция
                              // и список над которым надо совершить работу

evens oneToFive               // И запускаем функцию

// Вы можете использовать скобки для уточнения приоритета. В этом примере,
// сначала выполни "map" с двумя аргументами первым, потом выполни "sum" над результатом.
// Без скобок, "List.map" будет передано как как аргумент List.sum
let sumOfSquaresTo100 =
   List.sum ( List.map square [1..100] )

// Вы можете направить вывод одной операции в следующую используя "|>"
// Это та же sumOfSquares функция написанная с использованием конвейера
let sumOfSquaresTo100piped =
   [1..100] |> List.map square |> List.sum  // функция "square" определена ранее

// Вы можете определить лямбды (анонимные функции) используя ключевое слово "fun"
let sumOfSquaresTo100withFun =
   [1..100] |> List.map (fun x->x*x) |> List.sum

// В F# возврат неявный -- нет необходимости в "return". Функция всегда
// возвращает значение последнего использованного выражения.

// ======== Сопоставление с Образцом ========
// Match..with.. это заряженная конструкция case/switch.
let simplePatternMatch =
   let x = "a"
   match x with
    | "a" -> printfn "x is a"
    | "b" -> printfn "x is b"
    | _ -> printfn "x is something else"   // подчеркивание сопоставляется с чем угодно

// Some(..) и None это примерные аналоги обертки Nullable
let validValue = Some(99)
let invalidValue = None

// В этом примере, match..with сопоставляется с "Some" и "None",
// и одновременно с этим распаковывает значение из "Some".
let optionPatternMatch input =
   match input with
    | Some i -> printfn "input is an int=%d" i
    | None -> printfn "input is missing"

optionPatternMatch validValue
optionPatternMatch invalidValue

// ========= Сложные Типы Данных =========

// Кортежи - это пары, тройки и т.д. Кортежи используют запятые.
let twoTuple = 1,2
let threeTuple = "a",2,true

// Записи содержат именованые поля. В качестве разделителя используется точка с запятой.
type Person = {First:string; Last:string}
let person1 = {First="john"; Last="Doe"}

// Объединение содержит несколько возможных значений.
type Temp =
  | DegreesC of float
  | DegreesF of float
let temp = DegreesF 98.6

// Типы можно рекурсивно комбинировать сложными способами.
// Например, здесь используется объединение которое содержит список своего же типа:
type Employee =
  | Worker of Person
  | Manager of Employee list
let jdoe = {First="John";Last="Doe"}
let worker = Worker jdoe

// ========= Печать =========
// Функции printf/printfn схожи с
// функциями Console.Write/WriteLine в C#.
printfn "Printing an int %i, a float %f, a bool %b" 1 2.0 true
printfn "A string %s, and something generic %A" "hello" [1;2;3;4]

// все сложные типы имеют встроенную красивую печать
printfn "twoTuple=%A,\nPerson=%A,\nTemp=%A,\nEmployee=%A"
         twoTuple person1 temp worker

// Также существуют функции sprintf/sprintfn для форматирования данных
// в строку, аналогичные String.Format.


```

Итак, давайте начнем со сравнения некоего простого кода F# с эквивалентным  C# кодом.
